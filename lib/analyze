#!/bin/bash

# This program is free software. It comes without any warranty, to the
# extent permitted by applicable law. You can redistribute it and/or modify
# it under the terms of the Do What The Fuck You Want To Public License,
# Version 2, as published by Sam Hocevar. See WTFPL.txt or
# http://www.wtfpl.net/ for more details.


function analyze() {
  foods=()
  days=()
  points_by_day=()
  points_by_food=()
  points_total=0
  d=0
  while read day; do
    days["${d}"]="${day}"
    set -o pipefail
    while read food; do
      read servings
      read points
      if ! grep -qE '^[-0-9.]+$' <<< "${servings}"; then
        fail "Invalid number of servings of '${food}':" "'${servings}'"
      fi
      if ! grep -qE '^[-0-9.]+$' <<< "${points}"; then
        fail "Invalid number of points for '${food}':" "'${points}'"
      fi
      points_by_day["${d}"]="$(
        calculate "${points_by_day["${d}"]:-0} + ${points}"
      )" || fail "Failed to calculate points by day."
      points_total="$(
        calculate "${points_total} + ${points}"
      )" || fail "Failed to calculate points total."
      f=0
      for compiled_food in "${foods[@]}"; do
        if test "${compiled_food}" = "${food}"; then
          break 1
        fi
        f="$(( f + 1 ))"
      done
      if test "${#foods[@]}" = "${f}"; then
        foods["${f}"]="${food}"
      fi
      points_by_food["${d}"]="$(
        calculate "${points_by_food["${d}"]:-0} + ${points}"
      )" || fail "Failed to calculate points by food."
    done < <(
      ( analyze_day < "${state}/days/${day}" ) \
        || printf 'x\nx\nx\n'  # Cheap hack to induce parse failure.
    )
    set +o pipefail
    d="$(( d + 1 ))"
  done < <(ls "${state}/days/" | sort)
  average_points="$(
    calculate "${points_total} / ${#days[@]}"
  )" || fail "Failed to calculate average points."
  output "Number of days:" "${#days[@]}"
  output "Average points per day:" "${average_points}"
}


function analyze_day() {
  tally=0
  foods=()
  serving_counts=()
  point_counts=()
  while 
    read food
  do
    # Finish if no food is specified.
    if test "${food}" == ""; then
      break
    fi

    # Check for new food.
    if ! test -f "${state}/foods/${food}"; then
      fail "Unknown food:" "'${food}'"
    fi

    # Get points per serving.
    points_per_serving=$(cat "${state}/foods/${food}") \
      || fail "Failed to get points per serving."

    # Get count of servings.
    read servings

    # Check validity of input.
    if ! grep -qE '^[0-9.]+$' <<< "${servings}"; then
      fail "Invalid number of servings of ${food}:" "'${servings}'"
    fi

    # Do the math.
    points=$(
      calculate "${points_per_serving} * ${servings}"
    ) || fail "Failed to calculate points."

    tally=$(
      calculate "${tally} + ${points}"
    ) || fail "Failed to calculate tally."

    foods+=( "${food}" )
    serving_counts+=( "${servings}" )
    point_counts+=( "${points}" )
  done

  # Compile results.
  compiled_foods=()
  compiled_serving_counts=()
  compiled_point_counts=()
  f=0
  for food in "${foods[@]}"; do
    cf=0
    for compiled_food in "${compiled_foods[@]}"; do
      if test "${compiled_food}" = "${food}"; then
        break 1
      fi
      cf="$(( cf + 1 ))"
    done
    # Add food to list if not found.
    if test "${#compiled_foods[@]}" = "${cf}"; then
      compiled_foods["${cf}"]="${foods["${f}"]}"
    fi
    compiled_serving_counts["${cf}"]=$(
      calculate "${compiled_serving_counts["${cf}"]:-0} + ${serving_counts["${f}"]}"
    ) || fail "Failed to compile serving count for food:  '${food}'"
    compiled_point_counts["${cf}"]=$(
      calculate "${compiled_point_counts["${cf}"]:-0} + ${point_counts["${f}"]}"
    ) || fail "Failed to compile point count for food:  '${food}'"

    f="$(( f + 1 ))"
  done

  # Output results.
  cf=0
  for compiled_food in "${compiled_foods[@]}"; do
    printf "%s\n" "${compiled_food}"
    printf "%s\n" "${compiled_serving_counts["${cf}"]}"
    printf "%s\n" "${compiled_point_counts["${cf}"]}"
    cf="$(( cf + 1 ))"
  done
}
